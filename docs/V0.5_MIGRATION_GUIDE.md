# Cloud Cleaner v0.5.0 - Migration Guide

## Executive Summary

Version 0.5.0 transforms Cloud Cleaner from a hardcoded, resource-centric system to a dynamic, service-discovery architecture. This migration guide outlines the key changes and migration path.

## What's Changing

### Before (v0.4.x)
- ❌ Hardcoded resource types (EC2, EBS, S3, IAM only)
- ❌ Redis-only caching (no persistence)
- ❌ Manual resource type additions require code changes
- ❌ Separate API files for each resource type
- ❌ Frontend has hardcoded tabs

### After (v0.5.0)
- ✅ Dynamic service discovery via AWS Cost Explorer
- ✅ PostgreSQL database for persistence and history
- ✅ Plugin-based handler system for extensibility
- ✅ Single unified API for all resource types
- ✅ Frontend dynamically adapts to available services
- ✅ Only tracks services user actually uses

## Key Architecture Changes

### 1. Database Introduction

**PostgreSQL replaces Redis as primary data store**

Benefits:
- Historical cost tracking
- Resource lifecycle management
- Better query performance
- Data persistence across restarts
- Support for complex relationships

Tables:
- `aws_services` - Discovered AWS services
- `resources` - Individual resources across all services
- `cost_history` - Daily cost tracking per service
- `scan_history` - Audit trail of discovery scans

### 2. Service Discovery Engine

**Automatic detection of AWS services via Cost Explorer**

How it works:
1. Query AWS Cost Explorer for services with actual costs
2. Store discovered services in database
3. For each service, check if handler exists
4. If handler exists, scan for unused resources
5. Store resources and costs in database

Benefits:
- No manual configuration needed
- Only tracks services you actually use
- Accurate cost data from AWS
- Automatic updates as usage changes

### 3. Handler Registry System

**Plugin-like architecture for service handlers**

Structure:
```
backend/services/
  ├── base.py              # Base ServiceHandler class
  ├── registry.py          # Handler registration system
  ├── discovery.py         # Service discovery engine
  ├── ec2_handler.py       # EC2 service handler
  ├── ebs_handler.py       # EBS service handler
  ├── s3_handler.py        # S3 service handler
  ├── rds_handler.py       # NEW: RDS handler
  ├── lambda_handler.py    # NEW: Lambda handler
  └── ...                  # More handlers as needed
```

Each handler implements:
- `scan_unused_resources()` - Find unused resources
- `get_resource_cost()` - Calculate resource cost
- `delete_resource()` - Delete a resource

### 4. Unified API

**Single set of endpoints for all resource types**

New endpoints:
- `GET /api/services` - List all discovered services
- `GET /api/services/{code}/resources` - Get resources for service
- `GET /api/resources` - Get all unused resources
- `DELETE /api/resources/{id}` - Delete any resource
- `POST /api/scan` - Trigger discovery scan

Old endpoints (deprecated but functional):
- `GET /api/ec2/unused` → redirects to new API
- `GET /api/ebs/unused` → redirects to new API
- etc.

### 5. Dynamic Frontend

**Frontend adapts to available services**

Changes:
- No hardcoded resource tabs
- Tabs generated from `/api/services` response
- Resource tables work with any service type
- Cost analysis includes all discovered services

## Migration Path

### Phase 1: Preparation (Week 1)
- [ ] Review architecture documents
- [ ] Set up PostgreSQL in docker-compose
- [ ] Install new dependencies (alembic, asyncpg)
- [ ] Create database schema
- [ ] Run initial migrations

### Phase 2: Backend Implementation (Week 2-3)
- [ ] Implement database models
- [ ] Create service discovery engine
- [ ] Build handler registry system
- [ ] Migrate existing handlers (EC2, EBS, S3, IAM)
- [ ] Add new handlers (RDS, Lambda, etc.)
- [ ] Create new unified API endpoints
- [ ] Add backward compatibility layer

### Phase 3: Frontend Updates (Week 4)
- [ ] Update to consume new API
- [ ] Make resource tabs dynamic
- [ ] Update cost analysis for all services
- [ ] Add service discovery UI
- [ ] Test with various service combinations

### Phase 4: Testing & Deployment (Week 5)
- [ ] Run initial service discovery scan
- [ ] Verify data migration
- [ ] Test all handlers
- [ ] Performance testing
- [ ] Deploy to production
- [ ] Monitor for issues

### Phase 5: Cleanup (Week 6)
- [ ] Remove old API endpoints
- [ ] Clean up deprecated code
- [ ] Update documentation
- [ ] Announce new features

## Breaking Changes

### API Changes
- Old endpoints still work but are deprecated
- Response format slightly different (includes service metadata)
- New authentication may be required for Cost Explorer

### Configuration Changes
- New environment variables for database
- Cost Explorer must be enabled in AWS account
- May need additional IAM permissions

### Data Migration
- Existing cached data will be migrated to database
- Historical data before migration will be limited
- Cost data will be backfilled from Cost Explorer

## New Features Enabled

### Immediate Benefits
1. **Automatic Service Detection** - No configuration needed
2. **Historical Cost Tracking** - See cost trends over time
3. **More AWS Services** - RDS, Lambda, ElastiCache, etc.
4. **Better Performance** - Database queries vs API calls
5. **Data Persistence** - Survives restarts

### Future Capabilities
1. **Multi-Account Support** - Scan multiple AWS accounts
2. **Custom Handlers** - Users can add their own handlers
3. **ML Predictions** - Predict which resources will be unused
4. **Automated Cleanup** - Auto-delete based on rules
5. **Advanced Analytics** - Complex queries on historical data

## Required AWS Permissions

### New Permissions Needed
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ce:GetCostAndUsage",
        "ce:GetCostForecast",
        "pricing:GetProducts"
      ],
      "Resource": "*"
    }
  ]
}
```

### Cost Explorer Setup
1. Enable Cost Explorer in AWS Console
2. Wait 24 hours for data to populate
3. Verify access with test query
4. Configure in application settings

## Configuration Updates

### New Environment Variables
```bash
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@postgres:5432/cloud_cleaner
POSTGRES_PASSWORD=secure_password

# Service Discovery
DISCOVERY_SCAN_INTERVAL_HOURS=6
DISCOVERY_LOOKBACK_DAYS=30
MIN_COST_THRESHOLD=0.01

# Handler Configuration
ENABLE_AUTO_HANDLER_DISCOVERY=true
SUPPORTED_REGIONS=us-east-1,ap-south-1
```

### Docker Compose Updates
- Add PostgreSQL service
- Add volume for database persistence
- Update backend dependencies
- Add health checks

## Testing Strategy

### Unit Tests
- Test each handler independently
- Mock AWS API responses
- Verify database operations
- Test service discovery logic

### Integration Tests
- Test full scan workflow
- Verify data consistency
- Test API endpoints
- Check backward compatibility

### Performance Tests
- Measure scan duration
- Test with large datasets
- Verify database query performance
- Check memory usage

## Rollback Plan

If issues occur:

1. **Immediate Rollback**
   - Revert to v0.4.x containers
   - Keep database running (data preserved)
   - Old API endpoints still work

2. **Data Recovery**
   - Database backup before migration
   - Export data to JSON if needed
   - Restore from backup if necessary

3. **Gradual Migration**
   - Run both versions in parallel
   - Gradually shift traffic to new version
   - Monitor for issues

## Support & Resources

### Documentation
- [`ARCHITECTURE_V0.5.md`](ARCHITECTURE_V0.5.md) - Detailed architecture
- [`IMPLEMENTATION_PLAN_V0.5.md`](IMPLEMENTATION_PLAN_V0.5.md) - Implementation details
- API documentation at `/docs` endpoint

### Getting Help
- GitHub Issues for bugs
- Discussions for questions
- Slack channel for real-time support

## Timeline

- **Week 1**: Architecture review and database setup
- **Week 2-3**: Backend implementation
- **Week 4**: Frontend updates
- **Week 5**: Testing and deployment
- **Week 6**: Cleanup and documentation

**Target Release**: End of Week 5
**Deprecation of old API**: Week 12 (6 weeks after release)

## Success Metrics

- ✅ All existing services still work
- ✅ At least 5 new AWS services supported
- ✅ Scan completes in < 5 minutes
- ✅ Database queries < 100ms
- ✅ Zero data loss during migration
- ✅ 95% test coverage

## Next Steps

1. Review this migration guide
2. Read detailed architecture document
3. Set up development environment
4. Begin Phase 1 implementation
5. Regular check-ins with team

---

**Questions?** Open an issue or contact the team.